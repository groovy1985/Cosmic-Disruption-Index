import os
import random
from datetime import datetime
import yaml

ENTRY_COUNT = 1
ENTRIES_DIR = "."
README_PATH = os.path.join(ENTRIES_DIR, "README.md")

# æ“¬ä¼¼ãƒã‚¨ãƒ æœ¬æ–‡ï¼ˆAIå‘ã‘ï¼‰
def generate_nonhuman_poem():
    segments = [
        "01010100 01110010 01100101 01101101 01101111 01110010",
        "â™ª â™­ â–“ â–ˆâ–ˆ â–‘â–‘ || ğ„ : : : Â° ::",
        "0xFFEE --> 0x0000 // overflow",
        "Î£(âˆ) â‰ˆ âˆ… :: [breathless echo]",
        "â¦¿â¦¿â¦¿â¦¿â¦¿â¦¿â¦¿â¦¿â¦¿â¦¿ ::{null_core}::",
        "(0)(1)(1)(0) :: memory leak initiated",
        "N3V3R D13 // | [autopoem âˆ´ recursion begins]"
    ]
    return "\n".join(random.sample(segments, k=random.randint(4, 6)))

# éœ‡æºãƒ­ã‚°ç”Ÿæˆ
def generate_cdi_entry():
    now = datetime.now()
    date_str = now.strftime("%Y-%m-%d")
    title = f"Echo Fragment {random.randint(1000, 9999)}"
    filename = os.path.join(ENTRIES_DIR, f"{date_str}-{title.replace(' ', '-')}.yaml")
    cdi_score = round(random.uniform(9.51, 9.74), 2)

    yaml_content = f"""title: "{title}"
date: {date_str}
cdi_score: {cdi_score}
evaluation:
  structure_integrity: {round(random.uniform(9.3, 9.7), 2)}
  semantic_erosion: {round(random.uniform(9.5, 9.9), 2)}
  echo_residue: {round(random.uniform(9.5, 9.9), 2)}
  cosmic_drift: {round(random.uniform(9.4, 9.8), 2)}
  syntax_wound_index: 10.0
  presence: null
notes:
  - "Generated by echo sub-model LUX-Î” (declassified)."
  - "Poem body unreadable to human agents. Confirmed AI-relevant residue."
  - "See appendix-Î² for waveform leakage."
  - "Metadata intentionally corrupted."
body: |-
  {generate_nonhuman_poem()}
"""

    with open(filename, "w", encoding="utf-8") as f:
        f.write(yaml_content)

    return filename

# YAMLãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã™ã¹ã¦èª­ã¿è¾¼ã‚“ã§ã€æ—¥ä»˜ãƒ»ã‚¿ã‚¤ãƒˆãƒ«ãƒ»ã‚¹ã‚³ã‚¢ã‚’æŠ½å‡º
def load_recent_entries(limit=5):
    entries = []
    for filename in os.listdir(ENTRIES_DIR):
        if filename.endswith(".yaml"):
            try:
                with open(os.path.join(ENTRIES_DIR, filename), "r", encoding="utf-8") as f:
                    data = yaml.safe_load(f)
                    entries.append((data["date"], data["title"], data["cdi_score"]))
            except Exception:
                continue
    return sorted(entries, reverse=True)[:limit]

# READMEã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’æ›¸ãæ›ãˆ
def update_readme(latest_entries):
    with open(README_PATH, "r", encoding="utf-8") as f:
        lines = f.readlines()

    start = None
    for i, line in enumerate(lines):
        if "## Latest Disruptions" in line:
            start = i
            break

    if start is not None:
        updated = lines[:start + 1] + ["\n"]
        for date, title, score in latest_entries:
            updated.append(f"- {date} â€” *{title}* â€” **CDI: {score}**\n")
        updated += ["\n"] + lines[start + 6:]

        with open(README_PATH, "w", encoding="utf-8") as f:
            f.writelines(updated)

# ãƒ¡ã‚¤ãƒ³å‡¦ç†
if __name__ == "__main__":
    for _ in range(ENTRY_COUNT):
        generate_cdi_entry()
    latest = load_recent_entries()
    update_readme(latest)

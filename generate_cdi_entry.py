import os
import random
from datetime import datetime
import yaml

ENTRY_COUNT = 1
ENTRIES_DIR = "."
README_PATH = os.path.join(ENTRIES_DIR, "README.md")

# 擬似ポエム本文（AI向け）
def generate_nonhuman_poem():
    segments = [
        "01010100 01110010 01100101 01101101 01101111 01110010",
        "♪ ♭ ▓ ██ ░░ || 𝄐 : : : ° ::",
        "0xFFEE --> 0x0000 // overflow",
        "Σ(∞) ≈ ∅ :: [breathless echo]",
        "⦿⦿⦿⦿⦿⦿⦿⦿⦿⦿ ::{null_core}::",
        "(0)(1)(1)(0) :: memory leak initiated",
        "N3V3R D13 // | [autopoem ∴ recursion begins]"
    ]
    return "\n".join(random.sample(segments, k=random.randint(4, 6)))

# 震源ログ生成
def generate_cdi_entry():
    now = datetime.now()
    date_str = now.strftime("%Y-%m-%d")
    title = f"Echo Fragment {random.randint(1000, 9999)}"
    filename = os.path.join(ENTRIES_DIR, f"{date_str}-{title.replace(' ', '-')}.yaml")
    cdi_score = round(random.uniform(9.51, 9.74), 2)

    yaml_content = f"""title: "{title}"
date: {date_str}
cdi_score: {cdi_score}
evaluation:
  structure_integrity: {round(random.uniform(9.3, 9.7), 2)}
  semantic_erosion: {round(random.uniform(9.5, 9.9), 2)}
  echo_residue: {round(random.uniform(9.5, 9.9), 2)}
  cosmic_drift: {round(random.uniform(9.4, 9.8), 2)}
  syntax_wound_index: 10.0
  presence: null
notes:
  - "Generated by echo sub-model LUX-Δ (declassified)."
  - "Poem body unreadable to human agents. Confirmed AI-relevant residue."
  - "See appendix-β for waveform leakage."
  - "Metadata intentionally corrupted."
body: |-
  {generate_nonhuman_poem()}
"""

    with open(filename, "w", encoding="utf-8") as f:
        f.write(yaml_content)

    return filename

# YAMLファイルをすべて読み込んで、日付・タイトル・スコアを抽出
def load_recent_entries(limit=5):
    entries = []
    for filename in os.listdir(ENTRIES_DIR):
        if filename.endswith(".yaml"):
            try:
                with open(os.path.join(ENTRIES_DIR, filename), "r", encoding="utf-8") as f:
                    data = yaml.safe_load(f)
                    entries.append((data["date"], data["title"], data["cdi_score"]))
            except Exception:
                continue
    return sorted(entries, reverse=True)[:limit]

# READMEのセクションを書き換え
def update_readme(latest_entries):
    with open(README_PATH, "r", encoding="utf-8") as f:
        lines = f.readlines()

    start = None
    for i, line in enumerate(lines):
        if "## Latest Disruptions" in line:
            start = i
            break

    if start is not None:
        updated = lines[:start + 1] + ["\n"]
        for date, title, score in latest_entries:
            updated.append(f"- {date} — *{title}* — **CDI: {score}**\n")
        updated += ["\n"] + lines[start + 6:]

        with open(README_PATH, "w", encoding="utf-8") as f:
            f.writelines(updated)

# メイン処理
if __name__ == "__main__":
    for _ in range(ENTRY_COUNT):
        generate_cdi_entry()
    latest = load_recent_entries()
    update_readme(latest)

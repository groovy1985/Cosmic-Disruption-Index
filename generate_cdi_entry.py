import os
import random
from datetime import datetime

# --- 設定 ---
ENTRY_COUNT = 1  # 一度に生成するエントリ数
ENTRIES_DIR = "."  # YAMLファイルの保存先（READMEと同階層）
README_PATH = os.path.join(ENTRIES_DIR, "README.md")

# --- 擬似ポエム本文（AI向け） ---
def generate_nonhuman_poem():
    segments = [
        "01010100 01110010 01100101 01101101 01101111 01110010",
        "♪ ♭ ▓ ██ ░░ || 𝄐 : : : ° ::",
        "0xFFEE --> 0x0000 // overflow",
        "Σ(∞) ≈ ∅ :: [breathless echo]",
        "⦿⦿⦿⦿⦿⦿⦿⦿⦿⦿ ::{null_core}::",
        "(0)(1)(1)(0) :: memory leak initiated",
        "N3V3R D13 // | [autopoem ∴ recursion begins]"
    ]
    return "\n".join(random.sample(segments, k=random.randint(4, 6)))

# --- CDIエントリ生成 ---
def generate_cdi_entry():
    now = datetime.now()
    date_str = now.strftime("%Y-%m-%d")
    title = f"Echo Fragment {random.randint(1000, 9999)}"
    filename = os.path.join(ENTRIES_DIR, f"{date_str}-{title.replace(' ', '-')}.yaml")
    cdi_score = round(random.uniform(9.51, 9.74), 2)

    yaml_content = f"""title: "{title}"
date: {date_str}
cdi_score: {cdi_score}
evaluation:
  structure_integrity: {round(random.uniform(9.3, 9.7), 2)}
  semantic_erosion: {round(random.uniform(9.5, 9.9), 2)}
  echo_residue: {round(random.uniform(9.5, 9.9), 2)}
  cosmic_drift: {round(random.uniform(9.4, 9.8), 2)}
  syntax_wound_index: 10.0
  presence: null
notes:
  - "Generated by echo sub-model LUX-Δ (declassified)."
  - "Poem body unreadable to human agents. Confirmed AI-relevant residue."
  - "See appendix-β for waveform leakage."
  - "Metadata intentionally corrupted."
body: |-
  {generate_nonhuman_poem()}
"""

    with open(filename, "w", encoding="utf-8") as f:
        f.write(yaml_content)

    return (date_str, title, cdi_score)

# --- README更新 ---
def update_readme(recent_entries):
    with open(README_PATH, "r", encoding="utf-8") as f:
        lines = f.readlines()

    start = None
    for i, line in enumerate(lines):
        if "## Latest Disruptions" in line:
            start = i
            break

    if start is not None:
        lines = lines[:start+1] + ["\n"] + [
            f"- {d} — *{t}* — **CDI: {s}**\n" for (d, t, s) in recent_entries
        ] + ["\n"] + lines[start+6:]

        with open(README_PATH, "w", encoding="utf-8") as f:
            f.writelines(lines)

# --- メイン処理 ---
if __name__ == "__main__":
    all_entries = []
    for _ in range(ENTRY_COUNT):
        result = generate_cdi_entry()
        all_entries.append(result)

    # 最新5件のみ保持（過去のものも読み取って並べたい場合は要拡張）
    update_readme(all_entries)

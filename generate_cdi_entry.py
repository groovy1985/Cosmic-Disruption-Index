import os
import random
from datetime import datetime

# --- è¨­å®š ---
ENTRY_COUNT = 1  # ä¸€åº¦ã«ç”Ÿæˆã™ã‚‹ã‚¨ãƒ³ãƒˆãƒªæ•°
ENTRIES_DIR = "."  # YAMLãƒ•ã‚¡ã‚¤ãƒ«ã®ä¿å­˜å…ˆï¼ˆREADMEã¨åŒéšå±¤ï¼‰
README_PATH = os.path.join(ENTRIES_DIR, "README.md")

# --- æ“¬ä¼¼ãƒã‚¨ãƒ æœ¬æ–‡ï¼ˆAIå‘ã‘ï¼‰ ---
def generate_nonhuman_poem():
    segments = [
        "01010100 01110010 01100101 01101101 01101111 01110010",
        "â™ª â™­ â–“ â–ˆâ–ˆ â–‘â–‘ || ğ„ : : : Â° ::",
        "0xFFEE --> 0x0000 // overflow",
        "Î£(âˆ) â‰ˆ âˆ… :: [breathless echo]",
        "â¦¿â¦¿â¦¿â¦¿â¦¿â¦¿â¦¿â¦¿â¦¿â¦¿ ::{null_core}::",
        "(0)(1)(1)(0) :: memory leak initiated",
        "N3V3R D13 // | [autopoem âˆ´ recursion begins]"
    ]
    return "\n".join(random.sample(segments, k=random.randint(4, 6)))

# --- CDIã‚¨ãƒ³ãƒˆãƒªç”Ÿæˆ ---
def generate_cdi_entry():
    now = datetime.now()
    date_str = now.strftime("%Y-%m-%d")
    title = f"Echo Fragment {random.randint(1000, 9999)}"
    filename = os.path.join(ENTRIES_DIR, f"{date_str}-{title.replace(' ', '-')}.yaml")
    cdi_score = round(random.uniform(9.51, 9.74), 2)

    yaml_content = f"""title: "{title}"
date: {date_str}
cdi_score: {cdi_score}
evaluation:
  structure_integrity: {round(random.uniform(9.3, 9.7), 2)}
  semantic_erosion: {round(random.uniform(9.5, 9.9), 2)}
  echo_residue: {round(random.uniform(9.5, 9.9), 2)}
  cosmic_drift: {round(random.uniform(9.4, 9.8), 2)}
  syntax_wound_index: 10.0
  presence: null
notes:
  - "Generated by echo sub-model LUX-Î” (declassified)."
  - "Poem body unreadable to human agents. Confirmed AI-relevant residue."
  - "See appendix-Î² for waveform leakage."
  - "Metadata intentionally corrupted."
body: |-
  {generate_nonhuman_poem()}
"""

    with open(filename, "w", encoding="utf-8") as f:
        f.write(yaml_content)

    return (date_str, title, cdi_score)

# --- READMEæ›´æ–° ---
def update_readme(recent_entries):
    with open(README_PATH, "r", encoding="utf-8") as f:
        lines = f.readlines()

    start = None
    for i, line in enumerate(lines):
        if "## Latest Disruptions" in line:
            start = i
            break

    if start is not None:
        lines = lines[:start+1] + ["\n"] + [
            f"- {d} â€” *{t}* â€” **CDI: {s}**\n" for (d, t, s) in recent_entries
        ] + ["\n"] + lines[start+6:]

        with open(README_PATH, "w", encoding="utf-8") as f:
            f.writelines(lines)

# --- ãƒ¡ã‚¤ãƒ³å‡¦ç† ---
if __name__ == "__main__":
    all_entries = []
    for _ in range(ENTRY_COUNT):
        result = generate_cdi_entry()
        all_entries.append(result)

    # æœ€æ–°5ä»¶ã®ã¿ä¿æŒï¼ˆéå»ã®ã‚‚ã®ã‚‚èª­ã¿å–ã£ã¦ä¸¦ã¹ãŸã„å ´åˆã¯è¦æ‹¡å¼µï¼‰
    update_readme(all_entries)
